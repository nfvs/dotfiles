#!/bin/bash

alias l="ls -AvlhF --color=always --time-style=long-iso --group-directories-first"
alias ll="ls -AvhF --color=always --time-style=long-iso --group-directories-first"

_fzf_complete_git() {
    ARGS="$@"
    local branches
    branches=$(git branch -vv | sed 's/^.\{1\}//')
    # branches=$(git branch -vv)
    if [[ $ARGS == 'git co'* ]]; then
        echo "BRANCHES $branches"
        _fzf_complete --reverse --multi -- "$@" < <(
            echo $branches
        )
    else
        eval "zle ${fzf_default_completion:-expand-or-complete}"
    fi
}

_fzf_complete_git_post() {
    awk '{print $1}'
}


docker_cleanup() {
    docker_images_dangling_remove -f;
    docker_containers_stopped_remove "$@";
}

docker_images_dangling() {
    docker images "$@" --filter "dangling=true"
}

docker_images_dangling_remove() {
    docker_images_dangling --quiet | xargs docker rmi "$@";
}

docker_containers_stopped() {
    docker ps "$@" -a --filter 'exited=0'
}

docker_containers_stopped_remove() {
    docker_containers_stopped --quiet | xargs docker rm "$@";
}

# Look for the first python venv and activate it
# If called inside an existing one, will first deactivate it;
# will only re-activate if inside the path of a different one
venv() {
    local existing_venv
    local new_venv
    local first_venv_activate
    existing_venv="${VIRTUAL_ENV}"

    # Specified in args?
    new_venv="${1}"

    # ...otherwise look for the first one we can find
    if [ -z "${new_venv}" ]; then
        first_venv_activate="$(find "$(pwd -P)" -maxdepth 3 -type f -wholename '*/bin/activate' -exec grep -q "^VIRTUAL_ENV=.*" {} \; -print -quit)";
        if [ -n "${first_venv_activate}" ]; then
            new_venv="$(dirname "$(dirname "${first_venv_activate}")")"
        fi
    elif [ ! -f "$1/bin/activate" ]; then
        >&2 echo "No virtual env found in $1.";
        return 1
    fi

    # If we're in an existing venv, first deactivate it
    if [ -n "${existing_venv}" ]; then
        deactivate;
    # No existing venv, and no venv found -- error
    elif [ -z "${new_venv}" ]; then
        >&2 echo "No python virtual environments found.";
        return 1
    fi

    # Don't re-activate if we're inside the same one we just de-activated
    if [ -n "${new_venv}" ] && [ "${new_venv}" != "${existing_venv}" ]; then
        # shellcheck source=/dev/null
        . "${new_venv}/bin/activate";
    fi
}

find_largest() {
    find "${1:-.}" -type f -exec du -ah {} + | sort -h -r
}
